#!/usr/bin/env python
"""
Produces a subject x ROI .csv containing the correlations of that subject's
brain activity to the submitted template. The template can be either a ROI *
timepoint * subject .npy matrix, which can be used to generate multiple
templates using subsets of the data via monte carlo simulations, or a single
ROI * timepoint .csv.

This program accepts

The number of rows in each output .csv will match the number of input NIFTIs.

Usage:
    epi-xbrain-calc [options] <output> <template> <seeds> <nifti>...

Arguments:
    <output>        Output .csv filename.
    <template>      Input template.
    <seeds>         Mask with one or more ROI.
    <nifti>         Input niftis for subjects.

Options:
    --mask=<mask>   A binary brain mask.
    --n=<n>         Number of monte-carlo simulations to run [default: 10]
    --p=<p>         Proportion (0 < p < 1) of subjects taken for each simulation [default: 0.5]

DETAILS

    This computes the correlation of the mean time series within each ROI in
    the supplied mask with the template, for each subject.

    This program treats each unique input value in the seeds NIFTI as a unique
    ROI.

    epi-xbrain-calc -h or --help prints this message.
"""

import sys
import numpy as np
import scipy as sp
import nibabel as nib
import epitome as epi
from sklearn.cross_validation import KFold
from epitome.docopt import docopt

def get_mean_ts(data, seed):
    """
    takes one mean column of data for each unique value found in seed. returns a
    matrix with the number of rows of each column x the number of unique values
    in seed (excluding zero).
    """
    out_data = np.zeros(np.shape(data)[1])

    # get mean seed stat from each, append to output
    for s in np.unique(seed)[1:]:
        idx = np.where(seed == s)[0]
        seed_data = data[idx, :]
        seed_data = np.mean(seed_data, axis=0)
        out_data = np.vstack((out_data, seed_data))

    # strip off zeros
    out_data = out_data[1:,:]

    return out_data

def corrWithTemplate(template, seed, data, output):
    """
    Accepts a mean template (2d), seed mask (2d), and a list of input NIFTI
    files.

    Outputs a single csv file with one row of correlations per input NIFTI.
    """
    # init output matrix (TRs / ROIs)
    out_data = np.zeros((len(data), len(np.unique(seed)[1:])))

    for i, subj in enumerate(data):
        d, _, _, _ = epi.utilities.loadnii(subj)
        means = get_mean_ts(d, seed)

        if means.shape != template.shape:
            sys.exit('ERROR: Template shape {} does not match input {} shape {}.'.format(template.shape, subj, means.shape))

        # correlate template + means, save diagonal of off diagonal
        c = np.corrcoef(template, means)
        c = c[c.shape[0]/2:, 0:c.shape[0]/2]
        out_data[i, :] = c.diagonal()

    # write outputs
    np.savetxt(output, out_data, delimiter=",")

def main():
    arguments = docopt(__doc__)
    output   = arguments['<output>']
    template = arguments['<template>']
    seed     = arguments['<seeds>']
    data     = arguments['<nifti>']
    mask     = arguments['--mask']
    n        = int(arguments['--n'])
    p        = float(arguments['--p'])

    # parse inputs and define variables
    try:
        template = np.load(template)
        dtype = '3d'
    except IOError:
        try:
            template = np.genfromtxt(template, delimiter=',')
            dtype = '2d'
        except:
            sys.exit('ERROR: template {} not interpretable as either numpy matrix or .csv'.format(template))

    if dtype == '3d':
        if len(template.shape) != 3:
            sys.exit('ERROR: template {} is not 3D'.format(template))
        n_templates = template.shape[2]

    seed, _, _, _ = epi.utilities.loadnii(seed)
    _, _, _, dims = epi.utilities.loadnii(data[0])

    if mask:
        mask, _, _, _ = epi.utilities.loadnii(mask)
        # attempt to mask out non-brain regions in ROIs
        n_seeds = len(np.unique(seed))
        seed = seed * mask
        if len(np.unique(seed)) != n_seeds:
            sys.exit('ERROR: At least 1 ROI completely outside mask for {}.'.format(output))

    if p < 0 or  p > 0.9999:
        sys.exit('ERROR: p={} value invalid, should be 0 < p < 1'.format(p))

    if len(np.unique(seed))-1 != template.shape[0]:
        sys.exit('ERROR: The number of seeds in the input mask does not match the number of timeseries in the supplied template.')

    if dtype == '2d':
        corrWithTemplate(template, seed, data, output)
    else:
        # run monte carlo simulation
        for i in np.arange(n):
            # take a random subset of the input templates
            test = np.arange(n_templates)
            np.random.shuffle(test)
            test = test[:np.ceil(len(test)*p)]

            # take mean of template using subset
            subset = np.mean(template[:,:,test], axis=2)

            # generate output name
            outname = output.split('.')[0]
            outname = outname + '_{0:04d}.csv'.format(i+1)

            # generate one output
            corrWithTemplate(subset, seed, data, outname)

if __name__ == '__main__':
    main()

