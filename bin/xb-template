#!/usr/bin/env python
"""
Produces a 3D roi * timepoint * subject template matrix of the timeseries from
each ROI defined in the input mask across all of the input niftis. All time
series are scaled to percent signal change. This template can be used to
compute cross-brain correlations with held-out subjects using epi-xbrain-

Usage:
    epi-xbrain-template [options] <output> <seeds> <nifti>...

Arguments:
    <output>        Output filename.
    <seeds>         Mask with one or more ROI.
    <nifti>         Input niftis for subjects.

Options:
    --mask=<mask>   A binary brain mask.
    --var=<var>     Filename of the time series variance between subjects.
    --csv           Instead of outputting a 3D file, produces a simpler output
                    containing only the mean of the input subjects time series.

DETAILS

    This computes the mean time series within each ROI in the supplied mask.
    This program treats each unique input value in the seeds NIFTI as a unique
    ROI. It takes the mean time series within that ROI, and stores them for all
    input subjects. epi-xbrian-calc can then be used to generate multiple
    templates from subsets of these subjects. Alternatively, you can produce a
    single template csv. In this case, the program takes the mean time series
    between those ROIs to create a group template.

    epi-xbrain-template -h or --help prints this message.
"""

import sys
import numpy as np
import scipy as sp
import nibabel as nib
import epitome as epi
from epitome.docopt import docopt

def get_mean_ts(data, seed):
    """
    takes one mean column of data for each unique value found in seed. returns a
    matrix with the number of rows of each column x the number of unique values
    in seed (excluding zero).

    Each time series is finally converted to percent signal change by subtracting
    the mean and dividing by the mean.
    """
    out_data = np.zeros(np.shape(data)[1])

    # get mean seed stat from each, append to output
    for s in np.unique(seed)[1:]:
        idx = np.where(seed == s)[0]
        seed_data = data[idx, :]
        seed_data = np.mean(seed_data, axis=0)
        out_data = np.vstack((out_data, seed_data))

    # strip off zeros
    out_data = out_data[1:,:]

    # convert to percent signal change
    means = np.tile(np.mean(out_data, axis=1), [out_data.shape[1], 1]).transpose()
    out_data = (out_data-means)/means * 100

    return out_data

def main():
    arguments = docopt(__doc__)
    output = arguments['<output>']
    seed   = arguments['<seeds>']
    data   = arguments['<nifti>']
    mask   = arguments['--mask']
    var    = arguments['--var']
    csv    = arguments['--csv']

    if len(data) < 2:
        sys.exit('ERROR: Need at least two inputs to average')

    seed, _, _, _ = epi.utilities.loadnii(seed)
    _, _, _, dims = epi.utilities.loadnii(data[0])

    if mask:
        mask, _, _, _ = epi.utilities.loadnii(mask)
        # attempt to mask out non-brain regions in ROIs
        n_seeds = len(np.unique(seed))
        seed = seed * mask
        if len(np.unique(seed)) != n_seeds:
            sys.exit('ERROR: At least 1 ROI completely outside mask for {}.'.format(output))

    # init output matrix (TRs / ROIs)
    if csv:
        outDat = np.zeros((len(np.unique(seed)[1:]), dims[3]))
    else:
        outDat = np.zeros((len(np.unique(seed)[1:]), dims[3], len(data)))
    if var:
        outVar = np.zeros((len(np.unique(seed)[1:]), dims[3], len(data)))

    for i, subj in enumerate(data):
        subj, _, _, _ = epi.utilities.loadnii(subj)
        means = get_mean_ts(subj, seed)
        if csv:
            outDat = outDat + means
        else:
            outDat[:,:,i] = means

        if var:
            outVar[:,:,i] = means

    # write outputs
    if csv:
        outDat = outDat / len(subj)
        np.savetxt(output, outDat, delimiter=",")
    else:
        np.save(output, outDat)

    if var:
        outVar = np.var(outVar, axis=2)
        np.savetxt(var, outVar, delimiter=",")

if __name__ == '__main__':
    main()

